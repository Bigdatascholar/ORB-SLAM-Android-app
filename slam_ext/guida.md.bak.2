### Requisiti

- [Android-Cmake](https://github.com/taka-no-me/android-cmake)
- [CMake/CCMake](http://www.cmake.org): versione minima 3.2.2
- [Boost-for-Android](https://github.com/MysticTreeGames/Boost-for-Android): versione utilizzata 1.54
- [opencv4android](http://docs.opencv.org/doc/tutorials/introduction/android_binary_package/O4A_SDK.html)
- [G2O](https://openslam.org/g2o.html)
- [SuiteSparse-Cmake](https://github.com/jlblancoc/suitesparse-metis-for-windows)
- [CLapack](http://www.netlib.org/clapack/)
- [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page): versione minima 3.2.1
- [Sophus](https://github.com/strasdat/Sophus): contenuta in lsd-slam

## Android SDK / NDK

Scaricare l'SDK e l'NDK di android dai siti ufficiali e salvarli in una directory facilmente accessibile. Le versioni utilizzate sono rispettivamente SDK api level 19 e NDK r10d.
A questo punto è comodo impostare delle variabili di ambiente contenenti le directory di riferimento di tutto l'ecosistema java/android. Per far questo andiamo ad esportare alcune variabili di ambiente direttamente alla fine del file di sistema `~/.bashrc`:

	|
	|altre cose già presenti nel file
	|

	###############ANDROID DEVELOPMENT##################
	export JAVA_HOME=/usr/lib/jvm/java-8-oracle
	export JDK_PATH=/usr/lib/jvm/java-8-oracle/bin
	export ANDROID_SDK=/home/fab/adt-bundle-linux-x86_64-20140702/sdk
	export ANDROID_NDK=/home/fab/android-ndk-r10d
	export PATH=$PATH:$JAVA_HOME:$JDK_PATH:$ANDROID_SDK/tools:$ANDROID_SDK/platform-tools:$ANDROID_NDK

`ANDROID_SDK` e `ANDROID_NDK` fanno riferimento a cartelle nella home del mio user personale quindi fate attenzione. Fatto questo i percorsi dell'SDK e dell'NDK sono ora facilmente raggiungibili da ogni sistema. Nel caso spostiate una cartella o cambiaste versione non dovete fare altro che modificare il percorso corrispondente.

## Android-Cmake

I progetti software C++ in Linux sono tipicamente sviluppati usando dei tool di compilazione che agevolano la gestione di tanti file. Il più utilizzato di tutti è sicuramente CMake. È possibile sfruttare lo stesso tool per la compilazione di librerie e applicativi c++ compatibili con android. Grazie ad **Android-Cmake** è possibile gestire facilmente la compilazione di tutto un progetto usando i compilatori (es `gcc`) distribuiti da android piuttosto che quelli per sistemi `x86`.

Scaricare **Android-Cmake** dal sito ufficiale e salvarlo in una directory facilmente accessibile. Sempre per comodità andiamo ad aggiungere ulteriori variabili d'ambiente al nostro sistema:
	
	export ANDROID_CMAKE=/home/fab/freelance/android-cmake

**Android-Cmake** fornisce una *toolchain* di programmazione che in automatico va a fare riferimento ai compilatori android, è utile quindi fare riferimento a questa toolchain con una variabile d'ambiente.

	export ANDTOOLCHAIN=$ANDROID_CMAKE/android.toolchain.cmake

A questo punto è possibile utilizzare `cmake` o la sua versione visuale `ccmake` per compilare un progetto c++ per android. Per fare questo bisogna però definire a linea di comando delle variabili che indicano a cmake quale toolchain e quale compilatore usare. viene quindi comodo definire degli *alias* di comandi complicati che risparmiano tempo di digitazione e riducono gli errori, questi alias fanno uso delle variabili di ambiente definite precedentemente quindi indipendenti da dove avete installato i vari pacchetti. Sempre in `~/.bashrc` aggiungere:

	alias android-cmake='cmake -DCMAKE_TOOLCHAIN_FILE=$ANDTOOLCHAIN -DCMAKE_MAKE_PROGRAM=$ANDROID_NDK/prebuilt/linux-x86_64/bin/make '
	alias android-ccmake='ccmake -DCMAKE_TOOLCHAIN_FILE=$ANDTOOLCHAIN -DCMAKE_MAKE_PROGRAM=$ANDROID_NDK/prebuilt/linux-x86_64/bin/make '

Quindi, il comando per lanciare cmake o ccmake diventano rispettivamente `$ android-cmake <DIRECTORY_CONTENTE_CMAKELIST.TXT>` e `$ android-ccmake <DIRECTORY_CONTENTE_CMAKELIST.TXT>`.

#### FindCmake

Android-Cmake permette di utilizzare ancora i moduli cmake per trovare le librerie nel sistema senza bisogno di impostarle a mano ogni volta. Per far questo bisogna utilizzare il comando cmake `find_host_package` al posto di `find_package`.

# Compilazione delle librerie

ORB_SLAM, nella sua versione *non-ros*, ha come uniche dipendenze esterne dirette OpenCV, G2O, Boost, Eigen e SuiteSparse. Ognuna di queste librerie deve quindi essere compilata separatamente per dispositivi android. G2O fornisce internamente una versione di CSparse mentre per compilare SuiteSparse abbiamo bisogno delle librerie lapack e blas, entrambe contenute nel package CLapack. Iniziamo da quest'ultima e poi risaliamo la catena di dipendenze.

## CLapack

Scaricare dal sito ufficiale CLapack e salvarlo in una posizione comoda.

	export CLAPACKDIR=/home/fab/freelance/clapack

CLapack fornisce i codice sorgenti di tre librerie: F2C, BLAS e Lapack. Per poter compilare le librerie in modalità compatibile per android vanno fatte alcune modifiche al codice sorgente e ai CMakeLists della libreria.

Nel file `$CLAPACKDIR/CMakeLists.txt`

- commentare la riga 3, 4, 14 e 24 che fanno riferimento al testing
- aggiungere prima di `if(WIN32 AND NOT CYGWIN)` le seguenti righe:
	`set(ANDROID TRUE)`
	`set(BUILD_ANDROID TRUE)`
	`set(CMAKE_POSITION_INDEPENDENT_CODE ON)`


Nel file `$CLAPACKDIR/SRC/CMakeLists.txt`

- riga 51, eliminare `../INSTALL/lsame.c`

Nel file `$CLAPACKDIR/BLAS/CMakeLists.txt`

- commentare `add_subdirectory(TESTING)`

Nel file `$CLAPACKDIR/F2CLIBS/libf2c/CMakeLists.txt`

- riga 2, eliminare main.c

Nel file `$CLAPACKDIR/F2CLIBS/libf2c/sysdep1.h`

- riga 11, sostituire con `#if 0`

Nel file `$CLAPACKDIR/F2CLIBS/libf2c/uninit.c`

- riga 234, sostituire con `#if 0`

Ora è possibile compilare la libreria. Posizionarsi in `$CLAPACKDIR` e 

	mkdir build
	cd build
	android-ccmake ..

A questo punto premere '*c*' per configurare cmake e impostare:

- `ANDROID_ABI -> armeabi-v7a with NEON`
- `ANDROID_NATIVE_API_LEVEL -> 19`
- `CMAKE_BUILD_TYPE -> Release`

premere '*c*' per riconfigurare e infine premere '*g*' per generare il **Makefile**. Lanciare il comando `cmake --build .` per far partire la compilazione. Verrà restituito un errore del tipo `arithchk: not found` ma non bisogna preoccuparsene. Rilanciare il comando di make per superare l'errore.
A questo punto, se non ci sono stati errori, sono statE generate le 3 librerie (statiche) del package:

- `$CLAPACKDIR/build/SRC/liblapack.a`
- `$CLAPACKDIR/build/BLAS/SRC/libblas.a`
- `$CLAPACKDIR/build/F2CLIBS/libf2c/libf2c.a`

## SuiteSparse

La versione di SuiteSparse necessaria è quella predisposta con CMakeList.txt che si può trovare [qui](https://github.com/jlblancoc/suitesparse-metis-for-windows).

	$ git clone https://github.com/jlblancoc/suitesparse-metis-for-windows.git

esportare la variabile di ambiente in `~/.bashrc`

	export SUITESPARSEDIR=/home/fab/freelance/suitesparse-metis-for-windows

Nel file `$SUITESPARSEDIR/CMakeLists.txt`

- riga 161, modificare `OFF` con `ON`
- riga 164-165, aggiungere `SET(SUITESPARSE_CUSTOM_F2C_LIB "" CACHE FILE "Path to custom library file for F2C")`
- riga 163, modificare `""` con `"$ENV{CLAPACKDIR}/build/BLAS/SRC/libblas.a"`
- riga 164, modificare `""` con `"$ENV{CLAPACKDIR}/build/SRC/liblapack.a"`
- riga 165, modificare `""` con `"$ENV{CLAPACKDIR}/build/F2CLIBS/libf2c/libf2c.a"`
- riga 169, modificare con `SET(SuiteSparse_LINKER_LAPACK_BLAS_LIBS ${SUITESPARSE_CUSTOM_LAPACK_LIB} ${SUITESPARSE_CUSTOM_BLAS_LIB} ${SUITESPARSE_CUSTOM_F2C_LIB})`

Nel file `$SUITESPARSEDIR/SuiteSparse/CMakeLists.txt`

- riga 5, modificare `-mtune=native` con `-mtune=generic-armv7-a -mfpu=neon`
- riga 6, modificare `-mtune=native` con `-mtune=generic-armv7-a -mfpu=neon`

Nel file `$SUITESPARSEDIR/SuiteSparse/SuiteSparse_config/CMakeLists.txt`

- riga 9, aggiungere `target_link_libraries(suitesparseconfig m)`

Ora è possibile compilare la libreria. Posizionarsi in `$SUITESPARSEDIR` e 

	mkdir build
	cd build
	android-ccmake ..

A questo punto premere '*c*' per configurare cmake, attendere il download di alcuni file necessari e impostare

- `ANDROID_ABI -> armeabi-v7a with NEON`
- `ANDROID_NATIVE_API_LEVEL -> 19`
- `CMAKE_BUILD_TYPE -> Release`
- `SHARED -> ON`

premere '*c*' per riconfigurare e infine premere '*g*' per generare il **Makefile**. Lanciare il comando `cmake --build .` per far partire la compilazione.
Se non ci sono stati errori sono state generate le diverse librerie dinamiche del package SuiteSparse.

## G2O

G2O è la più famosa libreria c++ per lo slam, sia 2D che 3D. Il punto di forza di G2O è l'integrazione interna di diversi risolutori matematici per la gestione di diversi tipi di slam. G2O dipende da SuiteSparse e in particolare dalle librerie `cholmod` e `csparse`. La seconda non è comunque indispensabile in quanto la libreria contiene una versione interna che, per motivi di compatibilità, è preferibile usare.

scarichiamo l'ultima versione di G2O dal sito

	svn co https://svn.openslam.org/data/svn/g2o

definiamo la variabile di ambiente

	export G2ODIR=/home/fab/freelance/g2o/trunk

Nel file `$G2ODIR/CMakeLists.txt`

sostituire le righe 107, 108 e 109 con

	set(ENV{CHOLMODDIR} "$ENV{SUITESPARSEDIR}/build/lib")
	set(ENV{CHOLMODINCLUDEDIR} "$ENV{SUITESPARSEDIR}/SuiteSparse/CHOLMOD/Include")
	include_directories($ENV{SUITESPARSEDIR}/SuiteSparse/SuiteSparse_config)
	find_host_package(Cholmod)
	set(BLAS_LIBRARIES_DIR $ENV{CLAPACKDIR}/BLAS/SRC)
	set(BLAS_LIBRARIES $ENV{CLAPACKDIR}/build/BLAS/SRC/libblas.a)
	find_host_package(BLAS)
	set(LAPACK_LIBRARIES_DIR $ENV{CLAPACKDIR}/build/SRC)
	set(LAPACK_LIBRARIES $ENV{CLAPACKDIR}/build/SRC/liblapack.a)
	find_host_package(LAPACK)	

- sostituire `FIND_PACKAGE(CSparse)` alla riga 124 (dopo la modifica di sopra) con `SET(CSPARSE_FOUND FALSE)`
- commentare le righe 143 e 144 per disabilitare `openMP`
- commentare le righe 154 e 155 per disabilitare `openGL`
- commentare la riga 163 per disabilitare `QGLViewer`
- commentare la riga 176 per disabilitare la compilazione dei G2O examples
- sostituire `FIND_PACKAGE(Eigen3)` alla riga 226 con `find_host_package(Eigen3)` 
- aggiungere `SET(G2O_LIB_TYPE SHARED)` dopo la riga 241

Nel file `$G2ODIR/cmake_modules/FindCholmod.cmake`

- aggiungere `$ENV{CHOLMODINCLUDEDIR}` prima di `$ENV{CHOLMODDIR}` alla riga 12
- commentare le righe 15, 16, 17

Nel file `$G2ODIR/EXTERNAL/ceres/fpclassify.h`

- sostituire `isnan(x)`, `isnormal(x)`, `isfinite(x)` e `isinf(x)` con `std::isnan(x)`, `std::isnormal(x)`, `std::isfinite(x)` e `std::isinf(x)` nelle righe 62, 63, 76 e 77.

Nel file `$G2ODIR/g2o/stuff/macros.h`

- commentare le righe da 51 a 54

Ora è possibile compilare la libreria. Posizionarsi in `$G2ODIR` e 

	mkdir build
	cd build
	android-ccmake ..

A questo punto premere '*c*' per configurare cmake, ignorare i warning premendo '*e*' e impostare

- `ANDROID_ABI -> armeabi-v7a with NEON`
- `ANDROID_NATIVE_API_LEVEL -> 19`
- `CMAKE_BUILD_TYPE -> Release`

premere '*c*' per riconfigurare, '*e*' per ignorare il warning se presente e infine premere '*g*' per generare il **Makefile**. Lanciare il comando `cmake --build .` per far partire la compilazione.

## Boost

Per compilare le boost basta seguire la guida sul sito ufficiale

	https://github.com/MysticTreeGames/Boost-for-Android

esportare la variabile di ambiente

	export BOOSTDIR=/home/fab/freelance/Boost-for-Android

Nel file `$BOOSTDIR/build/include/boost-1_53/boost/thread/pthread/thread_data.hpp`

- modificare riga 28 con `#if 0`

## OpenCV

Anche per OpenCV seguire i passi della guida per il download delle librerie precompilate

	http://docs.opencv.org/doc/tutorials/introduction/android_binary_package/O4A_SDK.html

esportare la variabile di ambiente

	export OPENCVDIR=/home/fab/freelance/OpenCV-android-sdk/sdk/native

##ORB_SLAM

esportare la variabile di ambiente

	export ORBSLAMDIR=/home/fab/freelance/ORB_SLAM

Sostituire i file `$ORBSLAMDIR/Thirdparty/g2o/g2o/types/sba/types_six_dof_expmap.cpp`, `$ORBSLAMDIR/Thirdparty/g2o/g2o/types/sba/types_six_dof_expmap.h`, `$ORBSLAMDIR/Thirdparty/g2o/g2o/types/sim3/types_seven_dof_expmap.cpp`, `$ORBSLAMDIR/Thirdparty/g2o/g2o/types/sim3/types_seven_dof_expmap.h` con i corrispettivi nella cartella del package G2O e ricompilare quest'ultimo.

Posizionarsi in `$ORBSLAMDIR` e 

	mkdir build
	cd build
	android-ccmake ..

A questo punto premere '*c*' per configurare cmake e impostare

- `ANDROID_ABI -> armeabi-v7a with NEON`
- `ANDROID_NATIVE_API_LEVEL -> 19`
- `CMAKE_BUILD_TYPE -> Release`

premere '*c*' per riconfigurare e infine premere '*g*' per generare il **Makefile**. Lanciare il comando `cmake --build .` per far partire la compilazione.

##GENERAZIONE DIZIONARIO

in `$ORBSLAMDIR/Thirdparty/DBoW2/demo/demo.cpp` si trova il codice di generazione dell vocabolario. In questo file è possibile impostare il numero di immagini da utilizzare il il formato del filename associato.

per compilare il tool basta portarsi in `$ORBSLAMDIR/Thirdparty/DBoW2` e 

	mkdir build
	cd build
	cmake ..
	make -j5

quindi lanciare il tool con il comando `./demo`, le immagini devono essere inserite nella cartella `$ORBSLAMDIR/Thirdparty/DBoW2/demo`.
